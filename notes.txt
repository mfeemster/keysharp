The original had some very severe flaws. It followed an early style of C# programming that would unnecessarily allocate many objects when they could instead just be reused.

Code changes:
	-Constructed a DOM from parsing the ahk script, then compiled that DOM and some custom IL code into an executable. Now, we convert the DOM into C# code, and then compile that. This is less error prone, and also gets rid of certain bugs.

Code obsolescence/deprecation:
	-No boilerplate registry code, C# handles it.
	-No need for the pcre regular expression library, C# handles it.
	-No conversions between char, CHAR_T, TCHAR, WCHAR, wchar_t, CStringA, CStringW, LPCSTR, LPCWSTR. C# uses unicode and all conversion routines are built in.
	-No need for custom copy-on-write string, KuString.
	-Stream/text file readers and writers in TextIO.h/cpp are no longer needed. C# handles internally.
	-SimpleHeap and the low level memory management code is no longer needed because C# is a garbage collected language. In extreme cases, ArrayPool can be used.
	-Vastly simplified code generation from IronAHK. Keysharp does ahk -> dom -> c# code -> compiler -> run. No custom IL is generated, and only slight manual traversing of the DOM is performed.
	-Rather than make every publicly available static function for scripting be a part of a massive class named Core, split them into many public static classes with public static methods.
	-No custom rand code for mt19937, C# already has this.
	-No need for qmath.h, C# already has its own math functions that are likely faster.
	-The files needed to run a standalone compiled executable (named test) are:
		-text.exe
		-test.dll
		-test.runtimeconfig.json
		-Keysharp.Core.dll
		
Bugs:
	-Space and enter did not properly trigger hotstrings.
	-Backspace within a trigger, then retyping it, would prevent triggering hotstrings.
	-Would not check on whether modifier keys were pressed. This caused the bug of ignoring the hotstring when a user selected all with Ctrl+A then started typing.
	-If a trigger were to match both a hotstring and hotkey, major multithreading bugs were present due to a lack of understanding about how asynchronous programming works. These were likely rare and intermittent bugs, but were nonetheless present.
	-Assignment statements were using CodeBinaryOperatorExpression which was adding unnecessary parentheses which caused compiler errors. Use CodeAssignStatement instead.
	-Creating empty hotstrings appeared not to work.
	-Creating a hotstring with a comment at the end interpreted it literally as part of the string. Eg. ::xx::replacetext ;hello  => would literally output "replacetext ;hello".
	-Dictionary creation could throw an exception.
	-Variable names for dictionary keys didn't work:
		myten = ten
		array := { (myten) : 10, twenty: 20, thirty: 30}
	-If not did not work, because parsing "not" was buggy. Bug fix and new implementation is also optimized.
	-If between did not support comparing strings.
	-Postfix decrement operator: x--, did not work.
	-The <<= >>= operators did not work for strings.
	-Bitwise not did not work.
	-Could not create an associative array with variables for keys.
	-ClipWait waited for text, but not file drop, which AHK did. It also imroperly waited for non-text types.
	-A_ScriptFullPath did not include the file name.
	-A_ScriptHwnd was not implemented;
	-A_TitleMatchMode was broken.
	-A_SendLevel was not implemented.
	-A_StoreCapsLockMode was not implemented.
	-CoordMode did not support Client.
	-While loops were broken.
	-FormatTime() was broken.
	-Escaped quotes in strings did not work.
	-Case sensitivity in InStr() was wrong and it also didn't support any match beyond the first one encountered.
	-StrSplit() did not properly handle blank entries.
	-Sort() did not support locales, and numeric sort (option n) was broken for decimal numbers.
	-FileGetTime() erroneously returned a long integer instead of the date time string.
	-File related functions did not properly use the current file loop if the passed in file name was empty.
			
Differences:
	-AHK says about the inc/dec ++/-- operators on empty variables: "Due to backward compatibility, the operators ++ and -- treat blank variables as zero, but only when they are alone on a line". Keysharp breaks this and will instead create a variable, initialize it to zero, then increment it. Example, a file with nothing but the line x++ in it, will end with a variable named x which has the value of 1.
	-In AHK, when applied to a power operation, the unary operators apply to the entire result. So -x**y really means -(x**y). In Keysharp, this behavior is different due to an inability to resolve bugs in the original code. So follow these rules instead:
		To negate the result of a power operation, use parentheses: -(x**y).
		To negate one term of a power operation before applying, use parentheses around the term: (-x)**y or -(x)**y
	-There is no such thing as dereferencing in C#, so the * operator is not supported.
		However the & operator is still supported to get the numeric value of the memory address at which an object is stored.
	-Object methods and properties will be case sensitive because that's how they are in C#.
	-Had to rework much of the infrastructure for dynamically calling methods and properties on objects, such as array.InsertAt(). This may or may not be more efficient.
	-No such thing as negative indices.
	-Array has a new method called Add() which should be more efficient than Push() when adding a single item. It also returns the length of the array after the add completes.
	-IronAHK used decimal in some math functions. Keysharp will just use double for everything.
	-AHK only supported Atan(), but Keysharp also supports Atan2(x, y).
	-Added hyperbolic versions of trigonometric functions: Sinh(), Cosh(), Tanh().
	-IronAHK did not implement OnClipboardChange().
	-IronAHK did not implement Loop Reg.
	-Added a new property named A_LoopRegValue which makes it easy to get a registry value when using Loop Reg.
	-AHK could not use multi character strings as delimiters for Loop Parse, but Keysharp supports this.
	-IronAHK did not support writing to the standard error output in FileAppend using **.
	-Not supporting R, Dn or Tn parameters in FormatDateTime(), except for 0x80000000 to disallow user overrides. If you want to specify a particular format or order, do it in the format argument. There is no need or reason to have one argument alter the other.
		The C# style formatters are supported: https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
	-AHK appears to have created a complex memory management system, because C++ does not inherently contain one. As such, functions like VarSetStrCapacity() exist, as well as special rules for when memory gets cleared. None of this exists in Keysharp because it's all managed by the .NET runtime. As such, functions like VarSetStrCapacity() will throw an exception if used.
	-Keysharp has a special variable called args which is the original, unaltered array passed into a function. All functions support this because they are all variadic. This is an alternative to the params variable listed in the AHK documentation, because params ia a reserved word in C#.
	-Because all functions are variadic, the * doesn't apply.
	-DllCall() requires the user to use a StrigBuffer object when specifying type "ptr" to hold a string that the function will modify, such as wsprintf. StringBuffer internally uses a StringBuilder which is how C# P/Invoke handles string pointers.
		--Do not use str if the function will modify it.
		--Also use "ptr" and StringBuffer for double pointer parameters such as LPTSTR*.
	-Function objects will need to be created to be used. They are not all created automatically on script load like the documentation says. Possibly might be a way for the compiler to detect which ones are used and do them automatically.
	-For CallbackCreate, the & option won't work. C# doesn't do functions the same way. Hopefully it doesn't matter. Just pass the parameters you need.
	-ListLines() is omitted because C# doesn't support it.
	-Process.Run() can take an extra string for the argument.
	-Exception classes aren't, and can't be, derived from KeysharpObject. That is because for the Exception mechanics to work in C#, all exception objects must be derived from the base System.Exception class, and multiple inheritance is not allowed.
	-IsAlpha(), IsUpper(), IsLower() do not accept a locale parameter because all strings are Unicode.
	-In SetTimer(), the priority is not -2147483648 and 2147483647, instead it is only 0-4.
		--Also, you cannot omit the function parameter to have it act on the last timer from this thread. You must explicitly pass the timer or function name to the timer so it knows which timer to operate on.
		--Timers are not disabled when the program menu is shown.
		--The callback is passed the function object as the first object, and the date/time the timer was triggered as a YYYYMMDDHH24MISS string. This allows the handler to alter the timer by passing the function object back to another call to SetTimer().
	-Renaming Keysharp.exe to run a specific script by default will not work.
	-A leading plus sign on numeric values, such as +123 or +0x123 is not supported. It has no effect anyway, so just omit it.
	-AHK does not support null, but Keysharp uses it in some cases to determine if a variable has ever been assigned to, such as with IsSet().
	-Most operator rules work, but statements like this one from the documentation will not due to the evaluation order of arguments: ++Var := X is evaluated as ++(Var := X)
		--Use var := x, ++var instead.
	-User defined classes will not be included in the first release.
	-User definable properties will not be included in the first release, and Map values will not be considered OwnProps until future work is done.
	-ObjPtr() is not implemented because objects can be moved by the GC.
	-Built in functions are case sensitive, because they are called directly in the generated code.
	-VarRef and reference variables are not supported.
		-Because of this, users will need to rework how they use MonitorGet(), MonitorGetWorkArea(), SplitPath(), FileGetShortcut(), StrReplace(), LoadPicture(), WinGetPos(), ImageSearch(), MouseGetPos(), 
		-Might be possible: https://stackoverflow.com/questions/8779731/how-to-pass-a-parameter-as-a-reference-with-methodinfo-invoke
	-There is no variable caching with strings vs numbers. All variables are C# objects.
	-Leading spaces and tabs are not omitted from the strings in continuation strings. They will be parsed as is, according to the options specified. Trailing spaces and tabs will not be trimmed unless rtrim is specified.
	-Implicit comparison to empty string is not supported:
		--If (x != ) is not supported
		--If (x != "") is supported
	-Dynamic variables references like %x% can only refer to a global. There is no way to access a local variable in C# via reflection.
	-In continuation statements, the smart behavior logic for left trimming each line is disabled. Lines are not left trimmed by default and are only left trimmed if LTrim is specified.
	-Ternary operators with multiple statements in a branch are not supported. Use an if/else statement instead if such functionality is needed.
	-Quotes in strings cannot be escaped with double quotes, they must use the escape character, `.
	-Internally, all vk and sc related variables are treated as int, unlike AHK where some are byte and others are ushort. Continually casting back and forth is probably bad for performance, so everything relating to keys is made to be int across the board.
	-The 40 character limit for hotstring abbreviations has been removed. There is no limit to the length.
	-The defaults for hotstring creation can be retrieved by the Script.DefaultHotstring* properties.
	-You cannot use the word "params" because it's a reserved word in C#.
	-FileGetSize() supports 'g' and 't' for gigabytes and terabytes.
	-Log() is by default base 10, but you can pass a double as the second parameter to specify a custom base.
	-Function objects are much slower than direct function calls due to the need to use reflection. So for repeated function calls, such as those involving math, it's best to use the functions directly.
	-The syntax used in Format() is exactly that of string.Format() in C#, except with 1-based indexing. Traditional AHK style formatting is not supported.
	-Regex does not use Perl Compatible Regular Expressions. Instead, it uses the built in C# RegEx library. This results in the following changes from AHK:
		-The following options are different:
			-A: Forces the pattern to be anchored; that is, it can match only at the start of Haystack. Under most conditions, this is equivalent to explicitly anchoring the pattern by means such as "^".
				-This is not supported, instead just use ^ or \A in your regex string.
			
			-C: Enables the auto-callout mode.
				-This is not supported. C# regular expressions don't support calling an event handler for each match. You must manually iterate through the matches yourself.
				
			-D: Forces dollar-sign ($) to match at the very end of Haystack, even if Haystack's last item is a newline. Without this option, $ instead matches right before the final newline (if there is one). Note: This option is ignored when the "m" option is present.
				-This is not supported, instead just use $. However, this will only match \n, not \r\n. To match the CR/LF character combination, include \r?$ in the regular expression pattern.
			
			-J: Allows duplicate named subpatterns.
				-This is not supported.
				
			-S: Studies the pattern to try improve its performance.
				-This is not supported. All RegEx objects are internally created with the RegexOptions.Compiled option specified, so performance should be reasonable.
				
			-U: Ungreedy.	
				-This is not supported, instead use ? after: *, ?, +, and {min,max}.
				
			-X: Enables PCRE features that are incompatible with Perl.
				-This is not supported because it's Perl specific.
				
			`a `n `r: Causes specific characters to be recognized as newlines.
				-This is not supported.
			
			\K is not supported, instead, try using (?<=abc)
			
			PCRE exceptions are not thrown when there is an error, isntead C# regex exceptions are thrown.
			
			To learn more about C# regular expression, see here: https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions
			
	-RegExMatch() omits the third parameter &OutputVar because it's a ref param, which is not supported. Instead, it's returned as a member in the result object.
	-SubStr() uses a default of 1 for the second parameter, StartingPos, to relieve the user of always having to specify it.
	-PixelGetColor() does not accept a mode as its third parameter.
	-SoundGetInterface() is not implemented because it's COM.
	-Run() and RunWait() take an extra parameter for the program arguments, rather than placing them inside of the program name string.
		-Run() does not take a ref param for OutputVarPID, and instead returns it.
		-RunWait() does not take a ref param for OutputVarPID, and instead returns an object with two members: OutputVarPID and ExitCode.
	-Double click handlers for buttons are not supported.
	-Spin boxes with paired "buddy" controls are not supported. Just use the regular spin box in C#.
	-Goto statements cannot use any type of variables. They must be labels known at compile time and function just like goto statements in C#.
	-Goto statements being called as a function like Goto("Label") are not supported. Instead, just use goto Label.
	-Enumerator.Call() is not supported because it takes ref variables.
	-Func isn't supported, but FuncObj is and is created by the Func() function.
		-This is because C# already contains a built in class named Func.
	-Deleting a tab via GuiCtrl.Delete() does not reassociate the controls that it contains with the next tab. Instead, they are all deleted.
	-ListView supports a new method DeleteCol() to remove a column.
	-When adding a ListView, the Count option is not supported because C# can't preallocate memory for a ListView.
	-TreeView supports a new method GetNode() which retrieves a raw winforms TreeNode object based on a passed in ID.
	-TabControl supports a new method SetTabIcon() to relieve the caller of having to use SendMessage().
	-IL_Create() only takes one parameter: LargeIcons. InitialCount and GrowCount are no longer needed because memory is handled internally.
	-Menu supports new methods HideItem(), ShowItem() and ToggleItemVis() which can show, hide or toggle the visibility of a specific menu item.
	-Menu supports a new method MenuItemId() to get the name of a menu item, rather than having to use DllCall().
	-Menu supports a new method SetForeColor() to set the fore (text) color of a menu item.
	-For slider events, the second parameter passed to the event handler will always be 0 because it's not possible to retrieve the method by which the slider was moved in C#.
	-New string method NormalizeEol() used to take in a string and make all line endings match the value passed in, or the default for the current environment.
	-CallbackFree() is no longer needed/supported because C# handles garbage collection.
	-The v1 Map methods MaxIndex() and MinIndex() are still supported.
	-New function GetScreenClip() used to return a bitmap screenshot of an area of the screen and optionally save it to file.
	-The sound functions don't have the concept of a "component" because the underlying NAudio library does not group hardware into components. However, the component parameter of the sound functions is kept for backward compatibility. Just use device name or index instead.
	-Two new functions for string: StartsWith() and EndsWith() to examine the beginning and end of a string.
	-The 3 and 5 options for DirSelect() don't apply in C#.
	-The size and positioning of some GUI components will be slightly different than AHK because WinForms uses different defaults.
	-Only Tab3 is supported, no older tab functionality is present.
	-Rich text boxes are supported by passing "RichEdit" to Gui.Add(). The same options from "Edit" are supported with the following caveats:
		-Multiline is true by default.
		-WantReturn and Password are not supported.
		-Upper and lower case are supported, but only for key presses, not for pasting.
	-Loading icons from .NET DLLs is supported by passing the name of the icon resource in place of the icon number.
	-A new accessor A_KeysharpCorePath provides the full path to the Keysharp.Core.dll file.
	-Optional function parameters can be specified using the ? suffix, however it is not needed or supported when referring to that parameter inside of the function.
	-Passing "GetCommandLine" to DllCall() won't work exactly as the examples show. Instead, the type must be "ptr" and the result must be wrapped in StrGet() like:
		-StrGet(DllCall("GetCommandLine", "ptr"))
		-Also, a new accessor has been added named A_CommandLine which returns the same value. This is the preferred method.
	-OnMessage() doesn't observe any of the threading behavior mentioned in the documentation. Instead, the handlers are called inline. The third parameter is just used to specify if the handler should be inserted, added or removed from the list of handlers for the specified message. The return value is observed and if not null or empty string, will prevent the remainder of the handlers from being called, as well as prevent any further processing of the message. Also, a GUI object is required for OnMessage() to be used.
	-The class name for statusbar/statusstrip objects created by Keysharp is "WindowsForms10.Window.8.app.0.2b89eaa_r3_ad1". However, for accessing
	a statusbar created by another, non .NET program, the class name is still "msctls_statusbar321".
	-A new function CopyImageToClipboard() is supported which copies an image, using the same arguments as LoadPicture(), to the clipboard. Note this is a fully separate copy and does not share any handle, or perform any file locking with the original image being read.
	-Tooltips function slightly differently. When specifying a coordinate for a ToolTip, it will attempt to show it relative to the currently focused Keysharp form. If there is no focused form, it will attempt to show it relative to the last form which was created. If none are found, it will use 
	the main form shown when double clicking the tray icon. If the form is minimized, then it will attempt to use the RestoreBounds property of the form. This may not work sometimes, so the ToolTip may never show in that case.
		-Tooltips cannot be used if the script is not persistent (meaning, it has no main window). This is because C# tooltips require a parent control or form.
	-TrayTip() has some differences:
		-Muting the sound played by the tip is not supported with the "Mute" option. The sound will be whatever the user has configured in their system settings.
		-The option 4 to use the program's tray icon is not supported. It is always shown in the title of the tip.
		-The option 32 to use the large version of the program's tray icon is not supported. Windows will always show the small version.
	-When sending a string through SendMessage() using the WM_COPYDATA message type, the caller is no longer responsible for creating the special
	COPYDATA struct. Instead, just pass WM_COPYDATA (0x4A) as the message type and the string as the lparam, and SendMessage() will handle it internally.
	-For transparent controls which are intended to be overlaid over other controls, special steps must be taken.
		-Specify BackgroundTrans in the options for the transparent control.
		-Then set the .Parent property of the transparent control to the one it's laid over.
		-Note that this makes the x and y coordinates of the control be relative to its parent, not the overall form.
	-Sleep() works, but uses Application.DoEvents() under the hood which is not a good programming practice and can lead to hard to solve bugs.
		-For this reason, it's recommended that users use timers for repeated execution rather than a loop with calls to Sleep().
	-Assignment statements inside of control statements, such as "if ((x := Func()))" must be enclosed in parentheses. This statement, "if (x := Func())" will not work.
	-Pausing a script, invluding via menu item, may not work exactly the same way as it does in AHK, so its' best to avoid calling Pause().
	-Variables used in assignments inside of control flow statements inside of functions must first be declared. For example:
		if ((x := myfunc()) ; will not work without declaring x first above.
	-The Optimization section of the #HotIf documentation doesn't apply to Keysharp because it uses compiled code, thus the expressions are never re-evaluated.
	-Global variables can be accessed from within class methods by using the program. prefix.
	-You don't have to use this. to access member variables in member functions. Instead, just reference the member variable using global, and that will distinguish it between a local function variable. Using this is still supported, but is slower.
		-Note that if a class and sublcass both have properties with the same name, the following rules apply when accessing the properties within a member function in the base class:
			-global propname refers to the property defined in the base class.
			-this.propname refers to the property in the most derived subclass.
		-To avoid confusion, it is best not to give properties the same name between base and sub classes.
	-Static class variables cannot be overridden in subclasses. So regardless of the class used to access the variable, they all refer to the same static member variable.
	-Static class member variable initializers like static x.y := z are not supported. Instead, just initialize in one step like static x := { "y", 42 }
	-__Init() and __New are not static. They are instance methods so they can access static and instance member variables.
	-Nested classes are not supported.
	-Within a class, a property and a method cannot have the same name. However, they can if one is in a base class and the other is in a subclass.
	-The concept of a class prototype is not supported, because it doesn't exist in C# classes. Thus, there is no .Prototype member.
	-Properties other than __Item[] cannot take parameters. If you need to pass a parameter, use a method instead.
		-Variadic property parameters are not supported.
	-For any __Enum() class method, it should have a parameter value of 2 when returning Array or Map, since their enumerators have two fields.
	-Static __Item[] properties are not allowed, only instance __Item[] properties. This is because C# does not support static indexers.
	-The built in classes Array and Map do not have a property named __Item[] because in C#, the only properties which can have an index passed to them are the this[] properties. Just use the brackets directly. However, when overriding, using __Item[] will work if you derive from Array or Map.
	-A new method Collect() has been added which calls GC.Collect() to force a memory collection.
	-ObjAddRef() and ObjPtrAddRef() are not supported. Instead, use the following:
		newref := theobj ; adds 1 to the reference count
		newref := "" ; subtracts 1 from the reference count
	-#Warn to enable/disable compiler warnings is not supported yet.
	-The /script option for compiled scripts does not apply and is therefore not implemented.
	-In addition to using #ClipboardTimeout, an accessor named A_ClipboardTimeout can be used at any point in the program to get or set that value.
	-The #Requires directive differs in the following ways:
		-In addition to supporting "AutoHotkey", it also supports "Keysharp".
		-Sub versions such as -alpha and -beta are not supported, only the four numerical values values contained in the assembly version in the form of 0.0.0.0 are supported.
	-The #ErrorStdOut directive will not print to the console unless piping is used. For example:
		.\Keysharp.exe .\test.ahk | more
		.\Keysharp.exe .\test.ahk | more > out.txt
	-Pausing a script is not supported because it's actually a running program. As such, the pause menu item has been removed.
	-AHK does not support reloading a compiled script, however Keysharp does.
	-The Help and Window Spy menu items are not implemented yet.
	-AddStandard() detects menu items by string, instead of ID, because WinForms doesn't expose the ID.
	-A_EventInfo is not limited to positive values when reporting the mouse wheel scroll amount. When scrolling up, the value will be positive, and negative when scrolling down.
	-Download() only supports the *0 option, and not any other numerical values.
	-Using the class name with ClassNN on .NET controls gives long, version specific names because a simpler class name can't be specified in code the way it can in AHK with calls to CreatWindowEx().
		-So there is an additional NetClassNN property alongside ClassNN. This is used internally in the index operator for the Gui class, where if a control with a matching ClassNN is not found, then controls are searched for their NetClassNN values.
		-All GUI controls created in Keysharp are prefixed with the string "Keysharp". So for example: KeysharpButton, KeysharpEdit etc...
		
		
TODO/ENSURE THESE WORK:
	AHK uses a sort of pseudo-threading model so that one key can launch another, or a dialog can launch another. Figure out how to do this.
		Ensure V2 H multithreading works
		The function Thread() was never implemented, unsure how it will work with notimers and such.
		implement A_AllowTimers
	Go through change log in help file and see how much needs to be implemented in Keysharp.
			pull in latest ahk_v2 code to see what's changed.
	Include a command line switch to list all available pre-defined public functions which can be called from within a script.
	Ensure this works: https://lifehacker.com/use-autohotkey-to-scroll-the-command-prompt-backwards-b-5626708
	Perhaps look into including a long integer/extended precision library.
	What to do about references to specific locations named AutoHotkey, such as the library paths? Should we:
		-Keep that with no change.
		-No longer support it.
		-Support that, but also "Keysharp" in its place?
	A_IsPaused
	ListLines, A_ListLines
	Function objects will need to be created to be used, not all created on script load like the documentation says.
	Custom iterator objects won't be implemented.
	Ownprops
	threading interaction with timers
	Items under COM section
	Thread functionality, where things can be pre-empted/suspended/resumed etc...
	a way to test if you've implemented all functions: https://lexikos.github.io/v2/docs/commands/index.htm
	ensure you've properly captured all of these changes between 1.1 to 2.0: https://lexikos.github.io/v2/docs/v2-changes.htm
	See how much some of the existing plugins work with Keysharp: https://lexikos.github.io/v2/docs/commands/Edit.htm
	I'm not sure if we talked about this before but I just had a conversation in 
	meta about AltTab hotkeys and I just wanted to say: if you ever get around to them â€“ just leave them out. They serve next to no purpose, are very hackily implemented in AHK, they need a ton of edge-cases and weirdness, and they are just overall a mess. So yeah, just a heads-up I guess.
	If you want to read up on why I said this: https://discord.com/channels/115993023636176902/546213647526133760/888810883675983902

	tanks says:  also please msg me when you post code i very do mch want to feature it and offer direct hosting for downloads. we all accept that initial versions arent ready for primetime. but the more exposure the better.

	Here is an example of something not working because we haven't implemented threads properly.
	#MaxThreadsPerHotkey 3
	#z::  ; Win+Z hotkey (change this hotkey to suit your preferences).
	{
		static KeepWinZRunning := false
		if KeepWinZRunning  ; This means an underlying thread is already running the loop below.
		{
			KeepWinZRunning := false  ; Signal that thread's loop to stop.
			return  ; End this thread so that the one underneath will resume and see the change made by the line above.
		}
		; Otherwise:
		KeepWinZRunning := true
		Loop
		{
			; The next four lines are the action you want to repeat (update them to suit your preferences):
			ToolTip("Press Win-Z again to stop this from flashing.")
			Sleep(1000)
			ToolTip()
			Sleep(1000)
			; But leave the rest below unchanged.
			if(not KeepWinZRunning)  ; The user signaled the loop to stop by pressing Win-Z again.
				break  ; Break out of this loop.
		}
		KeepWinZRunning := false  ; Reset in preparation for the next press of this hotkey.
	}
	#MaxThreadsPerHotkey 1


	Give attribution to:
		Need to include this https://opensource.org/licenses/cddl1.php for the logical string comparison code: https://www.codeproject.com/Articles/22175/Sorting-Strings-for-Humans-with-IComparer
		Ini utility, attribution: https://www.codeproject.com/articles/20053/a-complete-win-ini-file-utility-class
		pinvoke.net (and make a donation)
		Tuple splatter extension methods, attribution: https://github.com/iotalambda/TupleSplatter/tree/master/TupleSplatter
		Rich text box with line numbers in Keyview: https://www.codeproject.com/Articles/38858/Line-Numbers-for-RichText-Control-in-C
		Semver: https://github.com/maxhauser/semver
		PictureBox derivation: https://www.codeproject.com/articles/717312/pixelbox-a-picturebox-with-configurable-interpolat
		Using SendMessage() with string: https://gist.github.com/BoyCook/5075907
		The program icon is a derivative of work by Bamicon: https://thenounproject.com/bamicon/

	Make sure all of these new V2 features work: https://lexikos.github.io/v2/docs/v2-changes.htm
	You could possibly make Any and KeysharpObject be interfaces, that way objects which already have a System base class, like Exception, could also be considered KeysharpObject. However, this probably wont' work because you do need a data member for the ownprops.
	
	There are four areas/types of versions being dealt with.
		1) The version of keysharp that is compiling the script.
		2) The embedded version of the script as specified by the #ASSEMBLY* directives.
		3) The version of keysharp that is running the script. Is the same as #1 when compiling.
		4) The version of keysharp the script was compiled with, to be checked when it's running.

	The command line you were using for Keysharp.OutputTest is: /force /restart /ErrorStdOut /Debug /include "IncFile.ahk"
	
	For when you implement classes/objects, here are how get/set properties are defined.
	
	x := Gui() ; this can be any object, built-in or not

	x.defineProp("SomethingUseless", {value: 123}
	x.defineProp("BitLessUseless", {get: (obj) => obj.SomethingUseless + 1}
	x.defineProp("EvenLessUseless", {
		get: (obj) => obj.SomethingUseless * 2,
		set: (obj, value) => obj.SomethingUseless := value / 2.0
	}
	x.defineProp("IncreaseUselessness", {call: (obj) => ++obj.EvenLessUseless}

	x.SomethingUseless ; 123
	x.SomethingUseless := 5 ; 5
	x.BitLessUseless ; 6
	x.BitLessUseless := 7 ; ERROR, property is read-only
	x.EvenLessUseless ; 10
	x.EvenLessUseless := 25 ; 25 (I think)
	x.IncreaseUsefullness() ; 26 (I think)
	x.SomethingUseless ; 13


	msgbox Hello World
	GoTo, Label2
	label1:
	msgbox Label1
	GoTo, LabExit
	Label2:
	msgbox Label2
	GoTo, Label1
	LabExit:
	msgbox Exitting now
	ExitApp
	
	You need to ensure hotkeys can pre-empt each other like this:
	Short example, not particularly useful but may be handy in testing:

		a::
		b::
		ToolTip, % A_ThisHotkey " is being held down."
		KeyWait, % A_ThisHotkey
		ToolTip

		if you hold down a and b it will show two tooltips
		and releasing each one individually will remove that tooltip

		v2 syntax would be this, in case it's more useful:

		a::
		b::
		toolTip A_ThisHotkey " is being pressed"
		keyWait A_ThisHotkey
		toolTip
		return

	Another example, which actually has a use is modifying the buttons in a MsgBox:
		(v2)

		fancyMsgBox(text, button1 := "", button2 := "", button3 := "") {
		  SetTimer applyButtonNames, -1
		  MsgBox text, "Fancy MsgBox", 0x3

		  applyButtonNames() {
			winWait "Fancy MsgBox"
			if button1
			  controlSetText button1, "Button1"
			if button2
			  controlSetText button2, "Button2"
			if button3
			  controlSetText button3, "Button3"
		  }
		}


			catch (KeysharpException kex)
			{
				MsgBox("Keysharp exception thrown:\r\n" +
					   "Message: " + kex.error.Message + "\r\n" +
					   "What: " + kex.error.What + "\r\n" +
					   "Extra: " + kex.error.Extra + "\r\n" +
					   "File: " + kex.error.File + "\r\n" +
					   "Line: " + kex.error.Line + "\r\n" +
					   "Stack: " + kex.error.Stack);
				Exit(1);
				return 1;
			}
			
			
	a function to make a console:
	#Persistent
Print(obj, quote:=False, end:="`n")
{
    static _ := DllCall("AllocConsole"), cout := FileOpen("CONOUT$", "w")
    , escapes := [["``", "``" "``"], ["""", """"""], ["`b", "``b"]
    , ["`f", "``f"], ["`r", "``r"], ["`n", "``n"], ["`t", "``t"]]
    if IsObject(obj) {
        for k in obj
            is_array := k == A_Index
        until !is_array
        cout.Write(is_array ? "[" : "{")
        for k, v in obj {
            cout.Write(A_Index > 1 ? ", " : "")
            is_array ? _ : Print(k, 1, "") cout.Write(": ")
            Print(v, 1, "")
        } return cout.Write(( is_array ? "]" : "}") end), end ? cout.__Handle : _
    } if (!quote || ObjGetCapacity([obj], 1) == "")
        return cout.Write(obj . end), end ? cout.__Handle : _
    for k, v in escapes
        obj := StrReplace(obj, v[1], v[2])
    while RegExMatch(obj, "O)[^\x20-\x7e]", m)
        obj := StrReplace(obj, m[0], Format(""" Chr({:04d}) """, Ord(m[0])))
    return cout.Write("""" obj """" . end), end ? cout.__Handle : _
}

			
			
	also, keep in mind, i'm going to have to spend significant time working on the design such that it builds on every OS, and doesn't blow up when someone tries to call a function that does not apply to the OS they're on
for example, let's say you try calling a registry-related function on linux. what should happen? should the script fail to compile? should it compile, but just have those functions do nothing? should it compile, run, and then have those functions throw an exception to end the program? many choices will have to be made, and i'm nowhere near that yet.
i'll also need substantial help testing. despite writing unit tests for each piece of functionality, i'm sure i will miss many of the corner cases. so i'll need a team of testers in close coordination and rapid communication to start testing their old scripts on multiple OSes and give me feedback on what isn't working. it will be a big effort.

INFO/FURTHER RESEARCH/OTHER PROJECTS:
	A version/fork of AHK called AHK_H which uses some threading, but not entirely: https://github.com/thqby/AutoHotkey_H
	This is just a thought for a future feature, perhaps pending extensive COM support. I've used code like this below to create Word instances in node-red using edge-js. IMHO support for at least MS Office apps would be a huge plus:
		Activator.CreateInstance(Type.GetTypeFromProgID("Word.Application")
	Be sure to keep in touch and coordinate with Tab Nation at https://www.youtube.com/c/TABNationAutoHotkey/videos and tadamm88@gmail.com
	Good writeup on scan codes and fake shift: https://www.win.tue.nl/~aeb/linux/kbd/scancodes-1.html
	Legacy style syntax is IfEqual, whereas new syntax is if (x = 1)
	Be sure A_ThisHotkey is set when calling a hotstring's function, so you can know which string triggered it.
	Hotstring() can also take special actions if the passed in strings are reserved values like "EndChars", "MouseReset", "Reset" or a string to set options with no colons.
	Labels are like functions, they run until a return. Unsure if they can return data?
		Dynamic calls are when the func/label name is contained in a variable. In that case, you must use reflection to look up the proper variable to call. Probably should wrap in a t/c.
	Hotkeys/strings also function as labels and can execute things until a return statement is encountered. They can also be goto'd.
	Loops can be labeled to allow for break out of nested loops.
	Might be usable: https://github.com/Paris/AutoHotkey-Scripts/blob/master/Functions.ahk and https://github.com/Paris/AutoHotkey-Scripts
	See here for more community: https://www.reddit.com/r/AutoHotkey
	Is it possible that all of this keyboard work can just be done in a cross-platform way with the Keyboard class?
	Make sure DPI scaling works: https://stackoverflow.com/questions/22735174/how-to-write-winforms-code-that-auto-scales-to-system-font-and-dpi-settings
	Look at https://espanso.org/ a cross platform text expander written in rust.
	https://github.com/mooz/xkeysnail
	https://github.com/rbreaves/kinto 
	http://daviddeley.com/autohotkey/xprxmp/autohotkey_expression_examples.htm
	https://github.com/Run1e/autohotkey-oofs
	https://stackoverflow.com/questions/27977924/in-windows-10-how-can-we-determine-which-virtual-desktop-a-window-belongs-to/32527200#32527200
	shutdown command on linux: https://stackoverflow.com/questions/11803283/shutdown-linux-using-c-sharp-and-mono/11803470#11803470
	 http://msdn.microsoft.com/en-us/library/aa376874%28v=vs.85%29.aspx
	 https://codegolf.stackexchange.com/questions/107874/shut-down-the-computer
	https://www.autohotkey.com/boards/viewtopic.php?f=37&t=29689
	https://www.alfredapp.com/
	https://forum.keyboardmaestro.com/
	give credit to: https://github.com/naudio/NAudio
	https://autohotkey.com/board/topic/50354-ironahk-alpha-cross-platform-net-rewrite-of-autohotkey/
	https://web.archive.org/web/20111026064713/http://www.ironahk.net/
	https://www.autohotkey.com/boards/viewtopic.php?f=17&t=30931
	https://www.autohotkey.com/boards/viewtopic.php?f=14&t=83012&p=363324#p363324
	Test regex with https://regex101.com/
	Script showcase: https://lexikos.github.io/v2/docs/scripts/
	Alternative ImageSearch: https://www.autohotkey.com/boards/viewtopic.php?p=86799#p86799
	GUI designer for AHK: https://www.autohotkey.com/board/topic/738-smartgui-creator/
	Text expander libraries that might show better ways to do hotstring parsing:
		https://github.com/natebean/SimpleTextExpander/tree/master/SimpleTextExpander
		https://beeftext.org/
		https://github.com/giosali/hypoinput
	More efficient hotstring matching from Mr. Doge in Discord: https://github.com/FuPeiJiang/Keysharp_hotstring.ah2
	Possible COM wrapper: https://www.codeproject.com/Articles/10888/SafeCOMWrapper-Managed-Disposable-Strongly-Typed-s
	When the time comes for adding web functionality: https://docs.microsoft.com/en-us/microsoft-edge/webview2/get-started/winforms
	DataGridView:
		https://github.com/topics/datagridview?l=c%23
		https://github.com/BekoSan/ProductivityFunctions
	A project that tried to use IronAHK to do automation in node.js: https://github.com/1j01/node-ahk
	RobotJS: an automation project in JS: https://github.com/octalmage/robotjs
	Messages in cosole apps: https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/june/net-matters-handling-messages-in-console-apps
	There is something called TVX, check it out sometime at www.autohotkey.com/forum/topic19021.html
	
	I am not sure what you mean by print. Do you mean something to write to the console? So in C++, it's printf() or cout, and in C# it's Console.WriteLine(). Something like that? I didn't know that AHK didn't have that. Are you sure? If it doesn't, then yes, we can add it in Keysharp. 
		
		In AHK, you can write to stdout using FileAppend by specifying * for the file name. 

			Thanks for reply. But, FileAppend just wirte to stdio not the console. DllCall("AllocConsole") is needed for wirting console. And AllocConsole will always display message in a new console
			
	Another code expander:
		https://github.com/giosali/reginald.
	Possibly investigate this later to see if it can be better than what we're doing with Windows API calls: https://mwinapi.sourceforge.net/
		-If not better, then at least see if it provides good examples.
	Possible COM library for MS Office. See how hard doing it from scratch is vs. this vs. copying some of its code:
		https://netoffice.io/
	For the linux work, SOTE on the forums said: phil294 (@phil294) whenever ready, who has an AHK Classic to Linux project on GitHub, and stated he would like to help in regards to Linux.
	https://www.codeproject.com/script/Content/ViewAssociatedFile.aspx?rzp=/KB/system/CSLLKeyboard//csllkeyboard_demo.zip&zep=BabyKeyboardBash/Keyboard.cs&obid=14485&obtid=2&ovid=1
	A general mouse and keyboard simulator: https://www.codeproject.com/Articles/28064/Global-Mouse-and-Keyboard-Library
	Another COM	solution which Burque has gotten to mostly work:
	https://www.codeproject.com/Articles/523417/Reflection-with-IDispatch-based-COM-objects
	How Powershell implements it: https://github.com/PowerShell/PowerShell/tree/master/src/System.Management.Automation/engine/COM
	An apparently cross platform desktop automation library: https://github.com/lucassklp/Desktop.Robot
	An event hook example library: https://github.com/Hema2-official/accprez/tree/main/Accprez
	
	
Closed development links to revisit:
	https://docs.microsoft.com/en-us/dotnet/framework/tools/signtool-exe?redirectedfrom=MSDN
	https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.csharpcompilationoptions?view=roslyn-dotnet
	https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.keyboard.modifiers?view=netcore-3.1
	https://docs.microsoft.com/en-us/dotnet/core/project-sdk/msbuild-props
	https://stackoverflow.com/questions/604410/global-keyboard-capture-in-c-sharp-application
	https://stackoverflow.com/questions/44205260/net-core-copy-to-clipboard
	https://stackoverflow.com/questions/6929275/how-to-convert-a-virtual-key-code-to-a-character-according-to-the-current-keyboa
	https://www.codeguru.com/vb/gen/article.php/c19573/Microsoft-NET-CodeDom-Technology.htm
	https://begeeben.wordpress.com/2012/07/30/source-code-generation-example-using-codedom/
	https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/how-to-create-a-class-using-codedom
	https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/using-the-codedom
	https://www.codeproject.com/articles/18676/dynamic-code-generation-using-codedom
	https://www.codeproject.com/articles/490184/creating-a-codedom-modeling-the-semantics-of-code
	https://www.codeproject.com/tips/715891/compiling-csharp-code-at-runtime
	https://www.automatetheplanet.com/optimize-csharp-reflection-using-delegates/
	https://www.youtube.com/watch?v=EgwnFhptwxI

	
	A program called Voice Macro for automation.
	
	
	todo:

	Try:
	
	#Include <print>

`a`:=`"a`"`,b`:`=`"b`"`,`c`:`=`"`c`"`,`d`:`=`"`d`"`,`e`:`=`"`e`"`,f`:`=`"f`"`,`g`:`=`"`g`"
,`h`:`=`"`h`"`,`i`:`=`"`i`"`,`j`:`=`"`j`"`,`k`:`=`"`k`"`,`l`:`=`"`l`"`,`m`:`=`"`m`"`,n`:`=`"n`"
,`o`:`=`"`o`"`,`p`:`=`"`p`"`,`q`:`=`"`q`"`,r`:`=`"r`"`,`s`:`=`"`s`"`,t`:`=`"t`"`,`u`:`=`"`u`"
,v`:`=`"v`"`,`w`:`=`"`w`"`,`x`:`=`"`x`"`,`y`:`=`"`y`"`,`z`:`=`"`z`"

%`p%%r%%`i%%n%%t%(%`h% %`e% %`l% %`l% %`o%)

///////Code storage


//class stuff from chat

DefineProp is really the same thing as just defining a member on a class, just that it does not call meta-functions (__get, __set, __call).
Basically the syntax for DefineProp is obj.DefineProp(name, descriptor). descriptor decides what kind of member will be made: Either an instance/class variable, a property, or a method. These names are a little weird in AHK so let me show you an example:

class X {
    InstanceVar := 123
    static ClassVar := 456
    Property1 {
        get {
            return 123 ; this is the long way to define these
        }
        set {
            return 456 ; if set is omitted, the property is read-only, like in C#
        }
    }

    Property2 {
        ; slightly shorter
        get => 123
        set => 123
        ; set can be omitted again
    }

    ; the shortest way
    Property3 => "test"
    ; this is only specifying a getter, so it is read-only

    Method() {
        return 123456
        ; there is no shorthand for these, unfortunately
    }
    static ClassMethod() {
        return "whatever"
    }
}

If I were to define the same class with DefineProp, I would write it like this:
(Don't worry about what __init and static __new do for the moment, they just get called automatically)

class X {
    static __new() {
        this.DefineProp("ClassVar", {value: 456})
        this.DefineProp("ClassMethod", {
            call: () => "whatever"
        })
    }

    __init() {
        this.DefineProp("InstanceVar", {value: 123})
        this.DefineProp("Property1", {
            get: () => 123
            set: () => 456
        })
        this.DefineProp("Property2", {
            get: () => 123
            set: () => 123
        }
        this.DefineProp("Property3", {
            get: () => "test"
        })
        this.DefineProp("Method", {
            call: () => 123456
        })
    }
}

Note that this code might not run, because I don't remember if there are parameter requirements for the functions passed to get and set. There was definitely some magic there.


yes, since DefineProp is defined on Object and Prototype (which is what class instances are) inherits from Object.
so you can even do {}.defineProp(...), just on a plain object like that

//////////////////////////////


github post on creating standalone exe:
https://github.com/dotnet/roslyn/issues/57347

Gist of how to create a .NET executable with Roslyn that will run on its own. Create the DLL, then make the exe point to it: https://gist.github.com/svick/7c29e29a9db532af0c619e6f3e32e814
(might be possible to just use msbuild)

var compilation = CSharpCompilation.Create(null)
    .AddSyntaxTrees(SyntaxFactory.ParseSyntaxTree(@"System.Console.WriteLine(""Hello, World!"");"))
    .AddReferences(Directory.EnumerateFiles(@"C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\5.0.0\ref\net5.0", "*.dll")
        .Select(f => MetadataReference.CreateFromFile(f)));
    
var result = compilation.Emit(@"C:\code\tmp\HelloWorld\HelloWorld.dll");

foreach (var diagnostic in result.Diagnostics)
{
    Console.WriteLine(diagnostic);
}

HostWriter.CreateAppHost(
    appHostSourceFilePath: @"C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Host.win-x64\5.0.11\runtimes\win-x64\native\apphost.exe",
    appHostDestinationFilePath: @"C:\code\tmp\HelloWorld\HelloWorld.exe",
    appBinaryFilePath: @"C:\code\tmp\HelloWorld\HelloWorld.dll");
	
	
Here is how to get the app host path programatically:
using System.Xml;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Locator;

// Note: code using MSBuild has to be in another method than the call to MSBuildLocator
MSBuildLocator.RegisterDefaults();

string GetAppHostPath()
{
  var xml = @"
<Project Sdk=""Microsoft.NET.Sdk"">
    <PropertyGroup>
      <OutputType>Exe</OutputType>
      <TargetFramework>net5.0</TargetFramework>
    </PropertyGroup>
</Project>";

  var project = Project.FromXmlReader(XmlReader.Create(new StringReader(xml)), options: new()).CreateProjectInstance();

  project.Build("ProcessFrameworkReferences", loggers: null);

  return project.GetItems("AppHostPack").Single().GetMetadata("Path").EvaluatedValue;
}

Console.WriteLine(GetAppHostPath());
