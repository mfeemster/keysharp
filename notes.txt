The original had some very severe flaws. It followed an early style of C# programming that would unnecessarily allocate many objects when they could instead just be reused.

Code changes:
	-Constructed a DOM from parsing the ahk script, then compiled that DOM and some custom IL code into an executable. Now, we convert the DOM into C# code, and then compile that. This is less error prone, and also gets rid of certain bugs.

Code obsolescence/deprecation:
	-No boilerplate registry code, C# handles it.
	-No need for the pcre regular expression library, C# handles it.
	-No conversions between char, CHAR_T, TCHAR, WCHAR, wchar_t, CStringA, CStringW, LPCSTR, LPCWSTR. C# uses unicode and all conversion routines are built in.
	-No need for custom copy-on-write string, KuString.
	-Stream/text file readers and writers in TextIO.h/cpp are no longer needed. C# handles internally.
	-SimpleHeap and the low level memory management code is no longer needed because C# is a garbage collected language. In extreme cases, ArrayPool can be used.
	-Vastly simplified code generation from IronAHK. Keysharp does ahk -> dom -> c# code -> compiler -> run. No custom IL is generated, and only slight manual traversing of the DOM is performed.
	-Rather than make every publicly available static function for scripting be a part of a massive class named Core, split them into many public static classes with public static methods.
	-No custom rand code for mt19937, C# already has this.
	-No need for qmath.h, C# already has its own math functions that are likely faster.
	-The files needed to run a standalone compiled executable (named test) are:
		-text.exe
		-test.dll
		-test.runtimeconfig.json
		-Keysharp.Core.dll
		

		
	Syntax:
		-The syntax used in Format() is exactly that of string.Format() in C#, except with 1-based indexing. Traditional AHK style formatting is not supported.
		-In AHK, when applied to a power operation, the unary operators apply to the entire result. So -x**y really means -(x**y). In Keysharp, this behavior is different due to an inability to resolve bugs in the original code. So follow these rules instead:
			To negate the result of a power operation, use parentheses: -(x**y).
			To negate one term of a power operation before applying, use parentheses around the term: (-x)**y or -(x)**y
		-The default name for the array of parameters in a variadic function is "args", instead of "params". This is due to "params" being a reserved word in C#.
			-You cannot use the word "params" because it's a reserved word in C#.
		-DllCall() requires the user to use a StrigBuffer object when specifying type "ptr" to hold a string that the function will modify, such as wsprintf. StringBuffer internally uses a StringBuilder which is how C# P/Invoke handles string pointers.
			--Do not use str if the function will modify it.
			--Also use "ptr" and StringBuffer for double pointer parameters such as LPTSTR*.
		-A leading plus sign on numeric values, such as +123 or +0x123 is not supported. It has no effect anyway, so just omit it.
		-AHK does not support null, but Keysharp uses it in some cases to determine if a variable has ever been assigned to, such as with IsSet().
		-Most operator rules work, but statements like this one from the documentation will not due to the evaluation order of arguments: ++Var := X is evaluated as ++(Var := X)
			--Use var := x, ++var instead.
		-Implicit comparison to empty string is not supported:
			--If (x != ) is not supported
			--If (x != "") is supported
		-Leading spaces and tabs are not omitted from the strings in continuation strings. They will be parsed as is, according to the options specified. Trailing spaces and tabs will not be trimmed unless rtrim is specified.
		-In continuation statements, the smart behavior logic for left trimming each line is disabled. Lines are not left trimmed by default and are only left trimmed if LTrim is specified.
		-Ternary operators with multiple statements in a branch are not supported. Use an if/else statement instead if such functionality is needed.
		-Quotes in strings cannot be escaped with double quotes, they must use the escape character, `.
		-Dynamic variables references like %x% can only refer to a global variable. There is no way to access a local variable in C# via reflection.
		-Goto statements cannot use any type of variables. They must be labels known at compile time and function just like goto statements in C#.
		-Goto statements being called as a function like Goto("Label") are not supported. Instead, just use goto Label.
		-Enumerator.Call() is not supported because it takes ref variables.
		-The underlying function object class is called FuncObj. This was named so, instead of Func, because C# already contains a built in class named Func.
			-Func() is still used to create an instance of FuncObj, by passing the name of the desired function as a string.
		-Optional function parameters can be specified using the ? suffix, however it is not needed or supported when referring to that parameter inside of the function.	
		-Assignment statements inside of control statements, such as "if ((x := Func()))" must be enclosed in parentheses. This statement, "if (x := Func())" will not work.
		-Variables used in assignments inside of control flow statements inside of functions must first be declared. For example:
			if ((x := myfunc()) ; will not work without declaring x first above.
		-The #Requires directive differs in the following ways:
			-In addition to supporting "AutoHotkey", it also supports "Keysharp".
			-Sub versions such as -alpha and -beta are not supported, only the four numerical values values contained in the assembly version in the form of 0.0.0.0 are supported.	
		-Global variables can be accessed from within class methods by using the program. prefix.
		-Accessing class member variables within member functions does not require the this. prefix.
			-Instead, just reference the member variable using global, and that will distinguish it between a local function variable of the same name.
			-Using this is still supported, but is slower, so avoid using it.
		-If a class and sublcass both have properties with the same name, the following rules apply when accessing the properties within a member function in the base class:
			-global propname refers to the property defined in the base class.
			-this.propname refers to the property in the most derived subclass.
			-To avoid confusion, it is best not to give properties the same name between base and sub classes.
		-For any __Enum() class method, it should have a parameter value of 2 when returning Array or Map, since their enumerators have two fields.
		-Passing "GetCommandLine" to DllCall() won't work exactly as the examples show. Instead, the type must be "ptr" and the result must be wrapped in StrGet() like:
			-StrGet(DllCall("GetCommandLine", "ptr"))
		-Internally, all vk and sc related variables are treated as int, unlike AHK where some are byte and others are ushort. Continually casting back and forth is probably bad for performance, so everything relating to keys is made to be int across the board.
			-Regex does not use Perl Compatible Regular Expressions. Instead, it uses the built in C# RegEx library. This results in the following changes from AHK:
				-The following options are different:
					-A: Forces the pattern to be anchored; that is, it can match only at the start of Haystack. Under most conditions, this is equivalent to explicitly anchoring the pattern by means such as "^".
						-This is not supported, instead just use ^ or \A in your regex string.
					
					-C: Enables the auto-callout mode.
						-This is not supported. C# regular expressions don't support calling an event handler for each match. You must manually iterate through the matches yourself.
						
					-D: Forces dollar-sign ($) to match at the very end of Haystack, even if Haystack's last item is a newline. Without this option, $ instead matches right before the final newline (if there is one). Note: This option is ignored when the "m" option is present.
						-This is not supported, instead just use $. However, this will only match \n, not \r\n. To match the CR/LF character combination, include \r?$ in the regular expression pattern.
					
					-J: Allows duplicate named subpatterns.
						-This is not supported.
						
					-S: Studies the pattern to try improve its performance.
						-This is not supported. All RegEx objects are internally created with the RegexOptions.Compiled option specified, so performance should be reasonable.
						
					-U: Ungreedy.	
						-This is not supported, instead use ? after: *, ?, +, and {min,max}.
						
					-X: Enables PCRE features that are incompatible with Perl.
						-This is not supported because it's Perl specific.
						
					`a `n `r: Causes specific characters to be recognized as newlines.
						-This is not supported.
					
					\K is not supported, instead, try using (?<=abc)
					
				PCRE exceptions are not thrown when there is an error, isntead C# regex exceptions are thrown.
				To learn more about C# regular expression, see here: https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions
			
	Additions/Improvements: Keysharp has added/improved the following:
		-A new method to Array called Add() which should be more efficient than Push() when adding a single item because it is not variadic. It also returns the length of the array after the add completes.
		-Atan2(y, x) while AHK only supports Atan().
		-Hyperbolic versions of the trigonometric functions: Sinh(), Cosh(), Tanh().
		-A new property named A_LoopRegValue which makes it easy to get a registry value when using Loop Reg.
		-Process.Run/RunWait() can take an extra string for the argument instead of appending it to the program name string. The original functionality still works too. The new signature is: Run/RunWait(Target[, WorkingDir, Options, Args]).
		-ListView supports a new method DeleteCol() to remove a column.
		-TabControl supports a new method SetTabIcon() to relieve the caller of having to use SendMessage().
		-Menu supports new methods:
			-HideItem(), ShowItem() and ToggleItemVis() which can show, hide or toggle the visibility of a specific menu item.
			-MenuItemId() to get the name of a menu item, rather than having to use DllCall().
			-SetForeColor() to set the fore (text) color of a menu item.
		-The 40 character limit for hotstring abbreviations has been removed. There is no limit to the length.
		-FileGetSize() supports 'G' and 'T' for gigabytes and terabytes.
		-When adding a ListView, the Count option is not supported because C# can't preallocate memory for a ListView.
		-TreeView supports a new method GetNode() which retrieves a raw winforms TreeNode object based on a passed in ID.
		-SubStr() uses a default of 1 for the second parameter, StartingPos, to relieve the user of always having to specify it.
		-New string method NormalizeEol() used to take in a string and make all line endings match the value passed in, or the default for the current environment.
		-The v1 Map methods MaxIndex() and MinIndex() are still supported. They are also supported for Array.
		-New function GetScreenClip(x, y, width, height, filename) can be used to return a bitmap screenshot of an area of the screen and optionally save it to file.
		-Two new functions for strings: StartsWith() and EndsWith() to examine the beginning and end of a string.
		-Run/Wait(target, dir, options, args) can take a fourth parameter, args, for the program arguments, rather than placing them inside of the program name string.
		-Rich text boxes are supported by passing "RichEdit" to Gui.Add(). The same options from "Edit" are supported with the following caveats:
			-Multiline is true by default.
			-WantReturn and Password are not supported.
			-Upper and lower case are supported, but only for key presses, not for pasting.
		-Loading icons from .NET DLLs is supported by passing the name of the icon resource in place of the icon number.
		-A new accessor A_KeysharpCorePath provides the full path to the Keysharp.Core.dll file.
		-A new function CopyImageToClipboard() is supported which copies an image to the clipboard.
			-Using the same arguments as LoadPicture().
			-This is a fully separate copy and does not share any handle, or perform any file locking with the original image being read.
		-When sending a string through SendMessage() using the WM_COPYDATA message type, the caller is no longer responsible for creating the special COPYDATA struct.
			-Instead, just pass WM_COPYDATA (0x4A) as the message type and the string as the lparam, and SendMessage() will handle it internally.
		-A new method Collect() has been added which calls GC.Collect() to force a memory collection. This rarely ever has to be used in properly written code.
		-In addition to using #ClipboardTimeout, an accessor named A_ClipboardTimeout can be used at any point in the program to get or set that value.
		-AHK does not support reloading a compiled script, however Keysharp does.
		-A_EventInfo is not limited to positive values when reporting the mouse wheel scroll amount. When scrolling up, the value will be positive, and negative when scrolling down.
		-A new accessor named A_CommandLine which returns the command line string. This is preferred over passing "GetCommandLine" to DllCall() as noted above.
		-The defaults for hotstring creation can be retrieved by the global static DefaultHotstring* properties.
		-Log() is by default base 10, but you can pass a double as the second parameter to specify a custom base.
		-In SetTimer(), the priority is not -2147483648 and 2147483647, instead it is only 0-4.
			-The callback is passed the function object as the first argument, and the date/time the timer was triggered as a YYYYMMDDHH24MISS string for the second argument.
			-This allows the handler to alter the timer by passing the function object back to another call to SetTimer().
			-Timers are not disabled when the program menu is shown.			
	
	Removals:
		-Fat arrow functions like => are not implemented yet.
		-COM is not implemented yet.
		-User definable properties are not implemented yet, and Map values will not be considered OwnProps until future work is done.
		-VarSetStrCapacity() has been removed due to it being incompatible with the .NET memory model.
		-ListLines() is omitted because C# doesn't support it.
		-There is no such thing as dereferencing in C#, so the * dereferencing operator is not supported.		
		-The R, Dn or Tn parameters in FormatDateTime() are not supported, except for 0x80000000 to disallow user overrides. If you want to specify a particular format or order, do it in the format argument. There is no need or reason to have one argument alter the other.
			The C# style formatters are supported: https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
		-Static text controls do not send the Windows API WM_CTLCOLORSTATIC (0x0138) message to their parent controls.
		-IsAlpha(), IsUpper(), IsLower() do not accept a locale parameter because all strings are Unicode.
		-Renaming Keysharp.exe to run a specific script by default will not work.
		-ObjPtr() is not implemented because objects can be moved by the GC.
		-ObjGet/SetCapacity() are not implemented because C# manages its own memory internally.
		-Double click handlers for buttons are not supported.
		-Spin boxes with paired "buddy" controls are not supported. Just use the regular spin box in C#.
		-IL_Create() only takes one parameter: LargeIcons. InitialCount and GrowCount are no longer needed because memory is handled internally.
		-For slider events, the second parameter passed to the event handler will always be 0 because it's not possible to retrieve the method by which the slider was moved in C#.
		-PixelGetColor() does not accept a mode as its third parameter.
		-Run() does not take a ref param for OutputVarPID, and instead returns it.
		-RegExMatch() omits the third parameter &OutputVar because it's a ref param, which is not supported. Instead, it's returned as a member in the result object.
		-SoundGetInterface() is not implemented because it's COM.
		-The sound functions don't have the concept of a "component" because the underlying NAudio library does not group hardware into components. However, the component parameter of the sound functions is kept for backward compatibility. Just use device name or index instead.
		-The 3 and 5 options for DirSelect() don't apply in C#.
		-Only Tab3 is supported, no older tab functionality is present.
		-VarRef and reference variables are not supported.
			-Users will need to rework how they use MonitorGet(), MonitorGetWorkArea(), SplitPath(), FileGetShortcut(), StrReplace(), LoadPicture(), WinGetPos(), ImageSearch(), MouseGetPos().
				-They instead return Map objects whose keys match the names of what would have been the reference parameters.
			-Because reference variables are not supported, Run/RunWait() do not take &OutputVarPID as the last argument. Instead, Run returns OutputVarPID and RunWait() returns (ExitCode, OutputVarPID).
		-OnMessage() doesn't observe any of the threading behavior mentioned in the documentation because threading has not been implemented yet. Instead, the handlers are called inline.
			-The third parameter is just used to specify if the handler should be inserted, added or removed from the list of handlers for the specified message.
			-A GUI object is required for OnMessage() to be used.
		-Pausing a script is not supported because a Keysharp script is actually a running program.
			-The pause menu item has been removed.
		-ObjAddRef() and ObjPtrAddRef() are not supported. Instead, use the following:
			newref := theobj ; adds 1 to the reference count
			newref := "" ; subtracts 1 from the reference count
		-#Warn to enable/disable compiler warnings is not supported yet.
		-The /script option for compiled scripts does not apply and is therefore not implemented.
		-The Help and Window Spy menu items are not implemented yet.
		-Download() only supports the *0 option, and not any other numerical values.
		-Static class variables cannot be overridden in subclasses. So regardless of the class used to access the variable, they all refer to the same static member variable.
		-Static class member variable initializers like static x.y := z are not supported. Instead, just initialize in one step like static x := { "y", 42 }
		-Nested classes are not supported.
		-Within a class, a property and a method cannot have the same name. However, they can if one is in a base class and the other is in a subclass.
		-The concept of a class prototype is not supported, because it doesn't exist in C# classes. Thus, there is no .Prototype member.
		-Properties other than __Item[] cannot take parameters. If you need to pass a parameter, use a method instead.
			-Variadic property parameters are not supported.
		-Static __Item[] properties are not allowed, only instance __Item[] properties. This is because C# does not support static indexers.
		-The built in classes Array and Map do not have a property named __Item[] because in C#, the only properties which can have an index passed to them are the this[] properties.
			-Just use the brackets directly. However, when overriding, using __Item[] will work if you derive from Array or Map.

TODO/ENSURE THESE WORK:
	AHK uses a sort of pseudo-threading model so that one key can launch another, or a dialog can launch another. Figure out how to do this.
		Ensure V2 H multithreading works
		The function Thread() was never implemented, unsure how it will work with notimers and such.
		implement A_AllowTimers
	Go through change log in help file and see how much needs to be implemented in Keysharp.
	Include a command line switch to list all available pre-defined public functions which can be called from within a script.
	Ensure this works: https://lifehacker.com/use-autohotkey-to-scroll-the-command-prompt-backwards-b-5626708
	Perhaps look into including a long integer/extended precision library.
	What to do about references to specific locations named AutoHotkey, such as the library paths? Should we:
		-Keep that with no change.
		-No longer support it.
		-Support that, but also "Keysharp" in its place?
	A_IsPaused
	ListLines, A_ListLines
	Function objects will need to be created to be used, not all created on script load like the documentation says.
	Custom iterator objects won't be implemented.
	Ownprops
	threading interaction with timers
	Items under COM section
	Thread functionality, where things can be pre-empted/suspended/resumed etc...
	a way to test if you've implemented all functions: https://lexikos.github.io/v2/docs/commands/index.htm
	ensure you've properly captured all of these changes between 1.1 to 2.0: https://lexikos.github.io/v2/docs/v2-changes.htm
	See how much some of the existing plugins work with Keysharp: https://lexikos.github.io/v2/docs/commands/Edit.htm
	I'm not sure if we talked about this before but I just had a conversation in 
	meta about AltTab hotkeys and I just wanted to say: if you ever get around to them â€“ just leave them out. They serve next to no purpose, are very hackily implemented in AHK, they need a ton of edge-cases and weirdness, and they are just overall a mess. So yeah, just a heads-up I guess.
	If you want to read up on why I said this: https://discord.com/channels/115993023636176902/546213647526133760/888810883675983902

	tanks says:  also please msg me when you post code i very do mch want to feature it and offer direct hosting for downloads. we all accept that initial versions arent ready for primetime. but the more exposure the better.

	Here is an example of something not working because we haven't implemented threads properly.
	#MaxThreadsPerHotkey 3
	#z::  ; Win+Z hotkey (change this hotkey to suit your preferences).
	{
		static KeepWinZRunning := false
		if KeepWinZRunning  ; This means an underlying thread is already running the loop below.
		{
			KeepWinZRunning := false  ; Signal that thread's loop to stop.
			return  ; End this thread so that the one underneath will resume and see the change made by the line above.
		}
		; Otherwise:
		KeepWinZRunning := true
		Loop
		{
			; The next four lines are the action you want to repeat (update them to suit your preferences):
			ToolTip("Press Win-Z again to stop this from flashing.")
			Sleep(1000)
			ToolTip()
			Sleep(1000)
			; But leave the rest below unchanged.
			if(not KeepWinZRunning)  ; The user signaled the loop to stop by pressing Win-Z again.
				break  ; Break out of this loop.
		}
		KeepWinZRunning := false  ; Reset in preparation for the next press of this hotkey.
	}
	#MaxThreadsPerHotkey 1


	Give attribution to:
		Need to include this https://opensource.org/licenses/cddl1.php for the logical string comparison code: https://www.codeproject.com/Articles/22175/Sorting-Strings-for-Humans-with-IComparer
		Ini utility, attribution: https://www.codeproject.com/articles/20053/a-complete-win-ini-file-utility-class
		pinvoke.net (and make a donation)
		Tuple splatter extension methods, attribution: https://github.com/iotalambda/TupleSplatter/tree/master/TupleSplatter
		Rich text box with line numbers in Keyview: https://www.codeproject.com/Articles/38858/Line-Numbers-for-RichText-Control-in-C
		Semver: https://github.com/maxhauser/semver
		PictureBox derivation: https://www.codeproject.com/articles/717312/pixelbox-a-picturebox-with-configurable-interpolat
		Using SendMessage() with string: https://gist.github.com/BoyCook/5075907
		The program icon is a derivative of work by Bamicon: https://thenounproject.com/bamicon/

	Make sure all of these new V2 features work: https://lexikos.github.io/v2/docs/v2-changes.htm
	You could possibly make Any and KeysharpObject be interfaces, that way objects which already have a System base class, like Exception, could also be considered KeysharpObject. However, this probably wont' work because you do need a data member for the ownprops.
	
	There are four areas/types of versions being dealt with.
		1) The version of keysharp that is compiling the script.
		2) The embedded version of the script as specified by the #ASSEMBLY* directives.
		3) The version of keysharp that is running the script. Is the same as #1 when compiling.
		4) The version of keysharp the script was compiled with, to be checked when it's running.

	The command line you were using for Keysharp.OutputTest is: /force /restart /ErrorStdOut /Debug /include "IncFile.ahk"
	
	For when you implement classes/objects, here are how get/set properties are defined.
	
	x := Gui() ; this can be any object, built-in or not

	x.defineProp("SomethingUseless", {value: 123}
	x.defineProp("BitLessUseless", {get: (obj) => obj.SomethingUseless + 1}
	x.defineProp("EvenLessUseless", {
		get: (obj) => obj.SomethingUseless * 2,
		set: (obj, value) => obj.SomethingUseless := value / 2.0
	}
	x.defineProp("IncreaseUselessness", {call: (obj) => ++obj.EvenLessUseless}

	x.SomethingUseless ; 123
	x.SomethingUseless := 5 ; 5
	x.BitLessUseless ; 6
	x.BitLessUseless := 7 ; ERROR, property is read-only
	x.EvenLessUseless ; 10
	x.EvenLessUseless := 25 ; 25 (I think)
	x.IncreaseUsefullness() ; 26 (I think)
	x.SomethingUseless ; 13


	msgbox Hello World
	GoTo, Label2
	label1:
	msgbox Label1
	GoTo, LabExit
	Label2:
	msgbox Label2
	GoTo, Label1
	LabExit:
	msgbox Exitting now
	ExitApp
	
	You need to ensure hotkeys can pre-empt each other like this:
	Short example, not particularly useful but may be handy in testing:

		a::
		b::
		ToolTip, % A_ThisHotkey " is being held down."
		KeyWait, % A_ThisHotkey
		ToolTip

		if you hold down a and b it will show two tooltips
		and releasing each one individually will remove that tooltip

		v2 syntax would be this, in case it's more useful:

		a::
		b::
		toolTip A_ThisHotkey " is being pressed"
		keyWait A_ThisHotkey
		toolTip
		return

	Another example, which actually has a use is modifying the buttons in a MsgBox:
		(v2)

		fancyMsgBox(text, button1 := "", button2 := "", button3 := "") {
		  SetTimer applyButtonNames, -1
		  MsgBox text, "Fancy MsgBox", 0x3

		  applyButtonNames() {
			winWait "Fancy MsgBox"
			if button1
			  controlSetText button1, "Button1"
			if button2
			  controlSetText button2, "Button2"
			if button3
			  controlSetText button3, "Button3"
		  }
		}


			catch (KeysharpException kex)
			{
				MsgBox("Keysharp exception thrown:\r\n" +
					   "Message: " + kex.error.Message + "\r\n" +
					   "What: " + kex.error.What + "\r\n" +
					   "Extra: " + kex.error.Extra + "\r\n" +
					   "File: " + kex.error.File + "\r\n" +
					   "Line: " + kex.error.Line + "\r\n" +
					   "Stack: " + kex.error.Stack);
				Exit(1);
				return 1;
			}
			
			
	a function to make a console:
	#Persistent
Print(obj, quote:=False, end:="`n")
{
    static _ := DllCall("AllocConsole"), cout := FileOpen("CONOUT$", "w")
    , escapes := [["``", "``" "``"], ["""", """"""], ["`b", "``b"]
    , ["`f", "``f"], ["`r", "``r"], ["`n", "``n"], ["`t", "``t"]]
    if IsObject(obj) {
        for k in obj
            is_array := k == A_Index
        until !is_array
        cout.Write(is_array ? "[" : "{")
        for k, v in obj {
            cout.Write(A_Index > 1 ? ", " : "")
            is_array ? _ : Print(k, 1, "") cout.Write(": ")
            Print(v, 1, "")
        } return cout.Write(( is_array ? "]" : "}") end), end ? cout.__Handle : _
    } if (!quote || ObjGetCapacity([obj], 1) == "")
        return cout.Write(obj . end), end ? cout.__Handle : _
    for k, v in escapes
        obj := StrReplace(obj, v[1], v[2])
    while RegExMatch(obj, "O)[^\x20-\x7e]", m)
        obj := StrReplace(obj, m[0], Format(""" Chr({:04d}) """, Ord(m[0])))
    return cout.Write("""" obj """" . end), end ? cout.__Handle : _
}

			
			
	also, keep in mind, i'm going to have to spend significant time working on the design such that it builds on every OS, and doesn't blow up when someone tries to call a function that does not apply to the OS they're on
for example, let's say you try calling a registry-related function on linux. what should happen? should the script fail to compile? should it compile, but just have those functions do nothing? should it compile, run, and then have those functions throw an exception to end the program? many choices will have to be made, and i'm nowhere near that yet.
i'll also need substantial help testing. despite writing unit tests for each piece of functionality, i'm sure i will miss many of the corner cases. so i'll need a team of testers in close coordination and rapid communication to start testing their old scripts on multiple OSes and give me feedback on what isn't working. it will be a big effort.

INFO/FURTHER RESEARCH/OTHER PROJECTS:
	A version/fork of AHK called AHK_H which uses some threading, but not entirely: https://github.com/thqby/AutoHotkey_H
	This is just a thought for a future feature, perhaps pending extensive COM support. I've used code like this below to create Word instances in node-red using edge-js. IMHO support for at least MS Office apps would be a huge plus:
		Activator.CreateInstance(Type.GetTypeFromProgID("Word.Application")
	Be sure to keep in touch and coordinate with Tab Nation at https://www.youtube.com/c/TABNationAutoHotkey/videos and tadamm88@gmail.com
	Good writeup on scan codes and fake shift: https://www.win.tue.nl/~aeb/linux/kbd/scancodes-1.html
	Might be usable: https://github.com/Paris/AutoHotkey-Scripts/blob/master/Functions.ahk and https://github.com/Paris/AutoHotkey-Scripts
	See here for more community: https://www.reddit.com/r/AutoHotkey
	Make sure DPI scaling works: https://stackoverflow.com/questions/22735174/how-to-write-winforms-code-that-auto-scales-to-system-font-and-dpi-settings
	Look at https://espanso.org/ a cross platform text expander written in rust.
	https://github.com/mooz/xkeysnail
	https://github.com/rbreaves/kinto 
	http://daviddeley.com/autohotkey/xprxmp/autohotkey_expression_examples.htm
	https://github.com/Run1e/autohotkey-oofs
	https://stackoverflow.com/questions/27977924/in-windows-10-how-can-we-determine-which-virtual-desktop-a-window-belongs-to/32527200#32527200
	shutdown command on linux: https://stackoverflow.com/questions/11803283/shutdown-linux-using-c-sharp-and-mono/11803470#11803470
	 http://msdn.microsoft.com/en-us/library/aa376874%28v=vs.85%29.aspx
	 https://codegolf.stackexchange.com/questions/107874/shut-down-the-computer
	https://www.autohotkey.com/boards/viewtopic.php?f=37&t=29689
	https://www.alfredapp.com/
	https://forum.keyboardmaestro.com/
	give credit to: https://github.com/naudio/NAudio
	https://autohotkey.com/board/topic/50354-ironahk-alpha-cross-platform-net-rewrite-of-autohotkey/
	https://web.archive.org/web/20111026064713/http://www.ironahk.net/
	https://www.autohotkey.com/boards/viewtopic.php?f=17&t=30931
	https://www.autohotkey.com/boards/viewtopic.php?f=14&t=83012&p=363324#p363324
	Test regex with https://regex101.com/
	Script showcase: https://lexikos.github.io/v2/docs/scripts/
	Alternative ImageSearch: https://www.autohotkey.com/boards/viewtopic.php?p=86799#p86799
	GUI designer for AHK: https://www.autohotkey.com/board/topic/738-smartgui-creator/
	Text expander libraries that might show better ways to do hotstring parsing:
		https://github.com/natebean/SimpleTextExpander/tree/master/SimpleTextExpander
		https://beeftext.org/
		https://github.com/giosali/hypoinput
	More efficient hotstring matching from Mr. Doge in Discord: https://github.com/FuPeiJiang/Keysharp_hotstring.ah2
	Possible COM wrapper: https://www.codeproject.com/Articles/10888/SafeCOMWrapper-Managed-Disposable-Strongly-Typed-s
	When the time comes for adding web functionality: https://docs.microsoft.com/en-us/microsoft-edge/webview2/get-started/winforms
	DataGridView:
		https://github.com/topics/datagridview?l=c%23
		https://github.com/BekoSan/ProductivityFunctions
	A project that tried to use IronAHK to do automation in node.js: https://github.com/1j01/node-ahk
	RobotJS: an automation project in JS: https://github.com/octalmage/robotjs
	Messages in cosole apps: https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/june/net-matters-handling-messages-in-console-apps
	There is something called TVX, check it out sometime at www.autohotkey.com/forum/topic19021.html
	Middle click scroll script for Notepad++: https://www.autohotkey.com/boards/viewtopic.php?p=34722&sid=9b2b27116d94f0552a149430d9ab623f#p34722
	
	I am not sure what you mean by print. Do you mean something to write to the console? So in C++, it's printf() or cout, and in C# it's Console.WriteLine(). Something like that? I didn't know that AHK didn't have that. Are you sure? If it doesn't, then yes, we can add it in Keysharp. 
		
		In AHK, you can write to stdout using FileAppend by specifying * for the file name. 

			Thanks for reply. But, FileAppend just wirte to stdio not the console. DllCall("AllocConsole") is needed for wirting console. And AllocConsole will always display message in a new console
			
	Another code expander:
		https://github.com/giosali/reginald.
	Possibly investigate this later to see if it can be better than what we're doing with Windows API calls: https://mwinapi.sourceforge.net/
		-If not better, then at least see if it provides good examples.
	Possible COM library for MS Office. See how hard doing it from scratch is vs. this vs. copying some of its code:
		https://netoffice.io/
	For the linux work, SOTE on the forums said: phil294 (@phil294) whenever ready, who has an AHK Classic to Linux project on GitHub, and stated he would like to help in regards to Linux.
	https://www.codeproject.com/script/Content/ViewAssociatedFile.aspx?rzp=/KB/system/CSLLKeyboard//csllkeyboard_demo.zip&zep=BabyKeyboardBash/Keyboard.cs&obid=14485&obtid=2&ovid=1
	A general mouse and keyboard simulator: https://www.codeproject.com/Articles/28064/Global-Mouse-and-Keyboard-Library
	Another COM	solution which Burque has gotten to mostly work:
	https://www.codeproject.com/Articles/523417/Reflection-with-IDispatch-based-COM-objects
	How Powershell implements it: https://github.com/PowerShell/PowerShell/tree/master/src/System.Management.Automation/engine/COM
	An apparently cross platform desktop automation library: https://github.com/lucassklp/Desktop.Robot
	An event hook example library: https://github.com/Hema2-official/accprez/tree/main/Accprez
	-Maybe do reference variables just for static function calls:
		-Might be possible: https://stackoverflow.com/questions/8779731/how-to-pass-a-parameter-as-a-reference-with-methodinfo-invoke
		
	
Closed development links to revisit:
	https://docs.microsoft.com/en-us/dotnet/framework/tools/signtool-exe?redirectedfrom=MSDN
	https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.csharpcompilationoptions?view=roslyn-dotnet
	https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.keyboard.modifiers?view=netcore-3.1
	https://docs.microsoft.com/en-us/dotnet/core/project-sdk/msbuild-props
	https://stackoverflow.com/questions/604410/global-keyboard-capture-in-c-sharp-application
	https://stackoverflow.com/questions/44205260/net-core-copy-to-clipboard
	https://stackoverflow.com/questions/6929275/how-to-convert-a-virtual-key-code-to-a-character-according-to-the-current-keyboa
	https://www.codeguru.com/vb/gen/article.php/c19573/Microsoft-NET-CodeDom-Technology.htm
	https://begeeben.wordpress.com/2012/07/30/source-code-generation-example-using-codedom/
	https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/how-to-create-a-class-using-codedom
	https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/using-the-codedom
	https://www.codeproject.com/articles/18676/dynamic-code-generation-using-codedom
	https://www.codeproject.com/articles/490184/creating-a-codedom-modeling-the-semantics-of-code
	https://www.codeproject.com/tips/715891/compiling-csharp-code-at-runtime
	https://www.automatetheplanet.com/optimize-csharp-reflection-using-delegates/
	https://www.youtube.com/watch?v=EgwnFhptwxI

	
	A program called Voice Macro for automation.
	
	
	todo:

	Try:
	
	#Include <print>

`a`:=`"a`"`,b`:`=`"b`"`,`c`:`=`"`c`"`,`d`:`=`"`d`"`,`e`:`=`"`e`"`,f`:`=`"f`"`,`g`:`=`"`g`"
,`h`:`=`"`h`"`,`i`:`=`"`i`"`,`j`:`=`"`j`"`,`k`:`=`"`k`"`,`l`:`=`"`l`"`,`m`:`=`"`m`"`,n`:`=`"n`"
,`o`:`=`"`o`"`,`p`:`=`"`p`"`,`q`:`=`"`q`"`,r`:`=`"r`"`,`s`:`=`"`s`"`,t`:`=`"t`"`,`u`:`=`"`u`"
,v`:`=`"v`"`,`w`:`=`"`w`"`,`x`:`=`"`x`"`,`y`:`=`"`y`"`,`z`:`=`"`z`"

%`p%%r%%`i%%n%%t%(%`h% %`e% %`l% %`l% %`o%)

///////Code storage


//class stuff from chat

DefineProp is really the same thing as just defining a member on a class, just that it does not call meta-functions (__get, __set, __call).
Basically the syntax for DefineProp is obj.DefineProp(name, descriptor). descriptor decides what kind of member will be made: Either an instance/class variable, a property, or a method. These names are a little weird in AHK so let me show you an example:

class X {
    InstanceVar := 123
    static ClassVar := 456
    Property1 {
        get {
            return 123 ; this is the long way to define these
        }
        set {
            return 456 ; if set is omitted, the property is read-only, like in C#
        }
    }

    Property2 {
        ; slightly shorter
        get => 123
        set => 123
        ; set can be omitted again
    }

    ; the shortest way
    Property3 => "test"
    ; this is only specifying a getter, so it is read-only

    Method() {
        return 123456
        ; there is no shorthand for these, unfortunately
    }
    static ClassMethod() {
        return "whatever"
    }
}

If I were to define the same class with DefineProp, I would write it like this:
(Don't worry about what __init and static __new do for the moment, they just get called automatically)

class X {
    static __new() {
        this.DefineProp("ClassVar", {value: 456})
        this.DefineProp("ClassMethod", {
            call: () => "whatever"
        })
    }

    __init() {
        this.DefineProp("InstanceVar", {value: 123})
        this.DefineProp("Property1", {
            get: () => 123
            set: () => 456
        })
        this.DefineProp("Property2", {
            get: () => 123
            set: () => 123
        }
        this.DefineProp("Property3", {
            get: () => "test"
        })
        this.DefineProp("Method", {
            call: () => 123456
        })
    }
}

Note that this code might not run, because I don't remember if there are parameter requirements for the functions passed to get and set. There was definitely some magic there.


yes, since DefineProp is defined on Object and Prototype (which is what class instances are) inherits from Object.
so you can even do {}.defineProp(...), just on a plain object like that

//////////////////////////////


github post on creating standalone exe:
https://github.com/dotnet/roslyn/issues/57347

Gist of how to create a .NET executable with Roslyn that will run on its own. Create the DLL, then make the exe point to it: https://gist.github.com/svick/7c29e29a9db532af0c619e6f3e32e814
(might be possible to just use msbuild)

var compilation = CSharpCompilation.Create(null)
    .AddSyntaxTrees(SyntaxFactory.ParseSyntaxTree(@"System.Console.WriteLine(""Hello, World!"");"))
    .AddReferences(Directory.EnumerateFiles(@"C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\5.0.0\ref\net5.0", "*.dll")
        .Select(f => MetadataReference.CreateFromFile(f)));
    
var result = compilation.Emit(@"C:\code\tmp\HelloWorld\HelloWorld.dll");

foreach (var diagnostic in result.Diagnostics)
{
    Console.WriteLine(diagnostic);
}

HostWriter.CreateAppHost(
    appHostSourceFilePath: @"C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Host.win-x64\5.0.11\runtimes\win-x64\native\apphost.exe",
    appHostDestinationFilePath: @"C:\code\tmp\HelloWorld\HelloWorld.exe",
    appBinaryFilePath: @"C:\code\tmp\HelloWorld\HelloWorld.dll");
	
	
Here is how to get the app host path programatically:
using System.Xml;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Locator;

// Note: code using MSBuild has to be in another method than the call to MSBuildLocator
MSBuildLocator.RegisterDefaults();

string GetAppHostPath()
{
  var xml = @"
<Project Sdk=""Microsoft.NET.Sdk"">
    <PropertyGroup>
      <OutputType>Exe</OutputType>
      <TargetFramework>net5.0</TargetFramework>
    </PropertyGroup>
</Project>";

  var project = Project.FromXmlReader(XmlReader.Create(new StringReader(xml)), options: new()).CreateProjectInstance();

  project.Build("ProcessFrameworkReferences", loggers: null);

  return project.GetItems("AppHostPack").Single().GetMetadata("Path").EvaluatedValue;
}

Console.WriteLine(GetAppHostPath());
